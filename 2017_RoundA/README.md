squareCounting.py: The key observation is that every tilted square (or oblique square, i.e. a square that does not align with the grid), must have been included in a minimum NON-tilted square (i.e. a square that align with the grid). e.g. the sample tilted square given in the problem spec, is included in a (minimum) 3\*3 square. More importantly, for each NON-tilted minimum square with side length L, we know there are exactly L-1 tilted squares included in it. Thus we can break the problem into two parts, first count the number of NON-tilted squares, and then add the number of tilted squares included in each NON-tilted squares. Note that we only do modulo after division operation.

patternOverlap.cpp: There are similar questions such as "wildcard matching" and "regular expression" matching on leetcode. But in this question, both of our strings can be pattern. So we have to deal with the case of mixed star and letters matching, e.g. \*\*a\*\*b\*\*c\*\*d\*\*e matching with ** should evaluate to true.

twoCubes.cpp: we first find the minimum rectangle box R that includes all stars. The first of the two cubes C1 must share a vertex with R. So there are 8 vertices of R, and thus 8 topologies for C1. For each of the topologies, we can binary search on a proposed side length L1 of C1, and for all stars that are not included in C1, we find the minimum side lenght L2 of cube C2 that containes all of them. We can find the minimum L1 such that L2<=L1, and that L1 is our answer.
