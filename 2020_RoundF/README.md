PaintersDuel.cpp: The problem can be solved by dfs based on the player's turn and state of graph. One thing that need to take care of is that in some cases, we need a left shift of more than 31 bits. Say we are trying to left shift 35 bits, we need to use 1LL<<35 instead of 1<<35 (which defaults to int type and cause undefined behavior). Besides that, we take the max possible difference when it is player A's turn, and minimum possible difference when it is player B's turn. helper.py is a python script that generates test cases for this problem. One of the input-out example pair is large-in-3.txt and large-out-3.txt.

ATMQueue.cpp: python submission might TLE with N log N algorithm, but C++ is safe.

MetalBurst.py: straightforward greedy.

yeetzhee.cpp: We maintain a vector S that records the mapping between group size and number of types. Let vector T be the vector we desire. Initially we have M types. If we have {2,2,3,5,5}, for example, then we have 2 types(2 and 5) for group size of 2, and 1 type (3) for group size of 1. Now at each step at index i of vector S, if there are some types at S\[i], we have the option to roll a dice of that type and move the type from S\[i] to S\[i+1]. Note that if the current prefix of S\[i] equals prefix of T\[i], we cannot perform the operation, otherwise we will never reach T. To calculate the expected steps, we need to use a formula, and I have included the formula in the comments.
