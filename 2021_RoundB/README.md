1.increasingSubstring: we maintain a how many chars before the current char forms a valid sequence. On the current char, either increase the previous sequence or abandon it and start again. <br>
2. longestProgression: There are two ways to approach it: a. we construct diff sequence, where diff is the difference between any two numbers. and then we greedily change one number to see if the diff groups connect and form bigger groups. b. we check for how long we can go with only one modification. Then if the prefix is a valid arithmetic array, we don't have to check for the prefix again. Therefore we jump to the end of the prefix and continue.<br>
3. consecutivePrimes: we look for one prime that is larger than sqrt(N) and two primes that are smaller than sqrt(N). <br>
4. TruckDelivery: The optimization comes from a segment tree structure. Note that our cities form a tree with N-1 edges, and the root is city 1. Therefore in a dfs traversal, for each city C we visit, we can assign it a topological number M. And for each city with order M, we can use the topological numbers to identify the range of cities (M_begin to M_end) that are the children of city C. Now, what it means for a city C2 to be the children of city C is that the path from 1 to C2 must include the path from 1 to C. This implies that if we make any changes to a path along 1 to C, all paths from 1 to C2 should be updated. In this sense, we create the segment tree that records segement from city C1 to city C2, and the greatest common divisor along the path C1 to C2. What's more, we are going to update this segment tree in increasing order of road limit or query weight. This is because if we update or query our segment tree in increasing order, when dealing with the current query we are only going to see all road limits that are smaller than the current weight, and all those roads with a larger road limit do not matter, and are therefore not within our considerations. In other words, we will sort the query or update operations based on road limits and weights, and perform an update operation if a road value is updated, perform a query operation if there is a weight to be queried. The root node of our segment tree contains the gcd from path 1 to N, and its left child contains gcd from path 1 to N/2, its right child from N/2+1 to N. With our segment S1 to S2 to be updated, we are going to update all segments in the tree such that they are fully contained within the range S1 to S2. When updating a value, we are going to do it lazily. Namely, we are going to update all segments within S1 to S2 but we only update the parent node that is fully contained in range S1 to S2, but not its children. By updating a value x along the path, we store the gcd of x and the original node value in each of these nodes. Therefore, when querying a range from city 1 to city C, we have to look at all segments that include C, because every segment that includes C could contain a lazy update that has not been propagated to its children. Remember that an update U1 to segment S1 to S2 means that for each node Sn on the path from S1 to S2, the gcd value from root node to node Sn (let this variable be G1) should be gcd-ed with the update U1. As we process our queries, we combine all the should be gcd-ed values of every segment in our segment tree that contains the query node Q. 
