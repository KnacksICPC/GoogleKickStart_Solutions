monsterPath.py: dfs works, note that the first grid does not count.

safeSquares.cpp: dp. The max side length of safesquare is denoted as maxL\[i]\[j]. It can be computed from maxL\[i-1]\[j],maxL\[i]\[j-1] and maxL\[i-1]\[j-1].

evaluation.py: topological sort. Note that the base case comes from any name whose parent is '' (the empty char). For example, in a valid expression a=f(), the name a has a single parent ''. On the other a=f(b) where b is not defined, is not a valid assignment.

soldiers.cpp: What matters are the relative orders of attack and defence. If there is a soldier with max attack and max defence, Alice picks it and wins. Otherwise, no one will pick a soldier with max attack or max denfence, because the other player can pick the complement soldier with max denfence or max attack and at least hold a tie. Thus we can remove the soldiers with max attack and max denfence and start another round. For example, if the soldiers are sorted by attacks, (A1,A1,A1),(A2),(A3,A3)... where A1>A2>A3. And also sorted by defence (D1),(D2,D2,D2,D2),(D3)... where D1>D2>D3. During the first round, if there is no soldier with both attack==A1 and defence==D1, we will remove both (A1,A1,A1) group and (D1) group. Similarly, if there is no soldier with both attack==A2 and defence==D2, we will remove both (A2) group and (D2,D2,D2,D2) group. Let us call the pair of groups with same index, "same-level" groups (i.e. A2 and D2 are "same-level", A10 and D10 are "same-level"). We keep removing the pair of groups that is at the same level, if at certain point there is a soldier with attack==An and defence==Dn Alice will win. If such a soldier does not exist, Bob wins. We can construct how Bob wins: no matter what Alice picks, Bob will pick a complement soldier that is at the same-level with what Alice picks. e.g. if Alice picks A19, Bob will pick D19, if later Alice picks A5, Bob will pick D5. This will guarantee Bob a tie.
