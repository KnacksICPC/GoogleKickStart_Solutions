lockedDoors.cpp: We first realize that the rooms we entered will always be a contiguous segment, let us call it E. E includes room S because S is where we started. Let A be the segmenet of doors opened to the left of room S, and let B be the segment of doors opened to the right of S. Let C be the first door to the left of A that we were not able to open, and let D be the first door to the right of B that we were not able to open. The topology looks like this, C + [  A   ] + S + [   B    ]+ D . Assume our valid segement of rooms E, (with length K) starts between A and C, and ends between B and D. Namely, let's assume our final answer of rooms includes door segment A+S+B but excludes door C and door D. For each door value V1 in A, we know V1 was obtained because, at some time in the process of opening doors, there was a bigger door value V2 on the right that forced us to have picked V1. This means that V1 has to be smaller than some value V2 on the right so that it was picked. This can be satisfied as long as there is at least one value on the right of S that was bigger than V1. For all such values of V1, this means the maximum of segment A should be smaller then the maximimum of segment B and door D, i.e. max(A)< max(max(B),D) . Let us call this condition I. Similarly, we know we were only able to pick every value V2 in B becuase at some time there was a worse value V1 on the left side such that V1>V2, and we chose V2 because it was smaller. This means the maximum of B should be smaller than the maximum of A and C, i.e. max(B)<max(max(A),C). Let us call this condition II. If condition I is violated, i.e., if max(A) > max(max(B),D), we know we have to move our segment E to the right (but we will always need to include room S), because if we move to the left, max(A) will get larger and max(max(B),D) will get smaller, which does not help with improving the situation. Similarly, if condition II is violated, we have to move our segment to the left. If both condition I and II are satisfied, we know the current segment E is the ONLY (unique) segment we wanted. To see why segment E is unique, I have included a picture lockedDoors.pdf. Up to now, we have locked down the segment E that we are interested in. Let F be the function that returns segement E, given S,K. Namely, let F(S,K)=E. The only question left is: which room is visited in the end? We know it has to be either the leftmost room of segment E, or the rightmost room of E. To determine exactly which one it is, we can look at the segment of rooms formed (let us call this segment G) if we have only visited K-1 rooms, i.e., let F(S,K-1)=G. If the left endpoint of segment of E and left endpoint of G are the same, we must have visited the last room on the right endpoint of E. Otherwise the leftendpoint of E and G will not be the same. Similarly, if the left endpoints of E and G are different, we must have visited the last room on the left endpoint of E. In this way, we can find E and G through binary search (based on condition I and II) in log(N) time. Thus Q queries will take Q log N time. We also need N log N time to build the range maximum query table so we can check condition I and II in O(1) time. Thus in total the run time of this solution is N log N + Q log N.  

beautyTree.cpp: For each node A, let the return value of dfs(A) be the number of times that A has been visited, by any path that started from node B, where node B is in A's subtree, i.e., B is a children of A. While we are iterating through dfs, we maintain a stack S of nodes that have been visited from top to bottom. To calculate dfs(A), we first run dfs(C) on each child C of A. And then, we check in S if there is a node D such that D is parent of A and D is M steps away from A. If so, we add the dfs(A) to the number of times D would have been visited in total.  
