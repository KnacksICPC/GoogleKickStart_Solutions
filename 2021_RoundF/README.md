trashBin.py: easy to solve, one can follow official analysis.<br /> <br />
Festival : Here, I would like to present a way of solving the question without having to use a segment tree, and also produces an equally good run time complexity as compared to that suggested by the official solution. First of all, we still transform all festival into start and end events, and sort them based on timestamps. Now, as we iterate over all these events, we maintain two heaps, one min heap, and the other one is a max heap. At a certain timestamp t, if we encounter a start event, we try to add the festival into the min heap. If the capacity is more than K, we pop the minimum value from the min heap and put it into the max heap. If later a lot of festivals end, and the min heap is smaller than size K, we could pop from the max heap and add festivals back into the min heap. We also keep a set to track all the invalid festival ids. As we iterate, we keep track of the maximum sum of happiness of festivals in the min heap, which would be our final answer. The overall complexity is N log N (sort) + N log N (heap push and pop), which is N log N. Details can be found in my implementation.<br /> <br />
StarTrappers.py: We consider the triangles and the four_sided_polygons. For the four_sided_polygons, we only consider those at the intersection of the diagonals. To group the diagnols, I choose the numerator / denominator integer pairs as the hash keys. After divided by a greatest common divisor,  numerator / denominator pairs can represent the tangent angles uniquely, and without loss of any precision. <br /> <br />
graphTravel.cpp: we use 16 bits to record all possible room combinations, and can compute the magic scores for each combination. As we iterate from state 0 to state (1<<15), at each state X, we find all of the next reachable states. For each reachable state Y, we add ways\[X] to ways\[Y], where ways\[] represents the number of unique ways to reach that state. And along the way, we add up all ways\[X] where score\[X] is K. This sum is our final result. 
