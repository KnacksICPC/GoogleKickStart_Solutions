SherlockAndParentheses.py: The topology ()()()(.. generates the maximum answer. Let the number of (s be A, let the number of )s be B, let P be min(A,B), we first state that the maximum number of balanced groups will not be more than P*(P+1)/2. Proof: without loss of generality, asssume A<=B. For the i th ( in the arrangement, we know there are at most A-i (s that come after it, thus the maximum number of balanced group that starts from the i th (, is (A-i)\*(A-i+1)/2. Summing up the value for each (, we know the total bound is A\*(A+1)/2, when A<B. Meanwhile, we know this bound is achievable because we can construct it with the topology ()()()(...

sherlockAndGymSecrets.cpp: we utilize the property that (i^A)%K is the same as (i%K)^A. Thus we can consider the numbers as groups, such that each group mod K with a different values. i.e. we split N into N1,N2,N3...Nk. Take N1 as an example, (all numbers in N1) % K==1. We also know exactly how many numbers are assigned to each group. For group Ni, there are N/K+(N%K >= i) numbers in it. Using fast exponential, we can calculate that for each T, how many numbers i there are such that (i%K)^A mod K==T. (Note that there can be multiple groups that contribute to T). Finally, we remove duplicate i,j pairs by iterating all different modulo results of K. 

watsonAndIntervals.cpp: Instead of thinking the intervals as intervals, we can think of each interval as two events, one happening at the start of the interval, and one happening at the end of the interval. Let us give each interval a unique id D, and use a hashset H to record how many events are currently active. For example, suppose we have an interval with id D and its interval is \[L,R]. We can view it as inserting D into the current hashset H at time L, and then remove D from the current hashset H at R. Now, if we maintain all intervals as two events, and keep all events in sorted order, as we iterate from earlier time to later time, we can keep track of how many points are scanned, when exactly one ID is active ( by active we mean exactly one ID exists in H). After finding the maximum points covered by exactly one ID, we subtract this value from the total points covered to obtain the final answer. 

SherlockAndPermutationSorting.cpp: Let us first look at a O(N^3) solution that is easier to come up with. Let an un-divisible chunk be a chunk of numbers that could not be divided into smaller chunks. For example, \[5,4,3,2,1] is one such block. \[2,1,3], on the other hand, is not an un-divisible chunk because it can be further divided into \[2,1] and \[3]. Let an un-divisible prefix be a prefix chunk with length L that is not further divisible. Then the number of un-divisible chunk of length N, is N! (N factorial) - (number of un-divisible prefix of length L )* (N-L)!  The theory behind this formula is that, from all permutations, we subtract those starting with a smaller un-divisible prefix, because anything that starts with a smaller un-divisible prefix is further divisible into that prefix and something else. With that, we can define dp\[i]\[j] as a number array with length i and can be maximally divided into j un-divisible chunks. Then, dp\[i]\[j]=sum of dp\[i-x]\[j-1], where x is the length an un-divisible chunk. The theory behind this is that, to get j un-divisible chunks, we first need to have some interval with j-1 un-divisible chunks, and another un-divisible chunk. Since we already know how to calculate the number of un-divisible chunks with length x, we can spend O(N) for each dp\[i]\[j] and in total we would spend O(N^3). Now, if you are some sort of genius with insights, there is also an O(N^2) solution that explores the relationship between squaresum\[i] and squaresum\[i-x], using un-divisible chunk concepts. 
