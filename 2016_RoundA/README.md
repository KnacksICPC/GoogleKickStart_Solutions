JaneFlowerShop.cpp: From the spec, "answers are accepted within error of 1e-6", and thus we know it is either binary search or tenary search. For binary search, we need to make sure the function is strictly increasing or strictly decreasing. Fortunately, even though the degree of our function is very high (up to 100), the spec guaranteed us that "there is exactly one solution in each test case". So we know that we are safe to use binary search. From the spec we also learnt that -1 < r < 1, and earning in each month is positive. If we plug in r=-1 to any of our functions, for example, -10000*(1+r)^3+3000*(1+r)^2+4000*(1+r)+5000=0, we would notice that every term that is multiplied with (1+r) evaluates to 0 and we are left with a positive value (in this case, 5000). So we know that our function started off to be greater than 0 at r=-1, gradually decreases as r increases, and at some point the funtion evaluates to 0, at which point we get our answer for r. With all that being said, we can run a binary search between -1 and 1, and look for our answer r.  

rain.py: same as leetcode 407.

clashRoyale.cpp: We recognize at first sight it is knapsack dp, but directly dp will cause MLE. Instead, we pay some time by splitting the entire dp process into two halves. For each half that is at most N/2, we maintain the maximum attack we would achieve if we select J cards from it, such that J is in the range(0,N/2) and the sum of cost do not exceed M. After we find out the J values (let them be J1, J2) for each half, we merge J1 and J2 together, such that J1+J2=8. e.g. if we have a total of 11 cards, we can select 2 cards from one half of 5 cards, and select 6 cards from the other half of 6 cards (in this example J1=2, J2=6). In each step of dp, we only keep the value pairs (cost, attack) if there does NOT exist another pair (cost2,attack2) such that cost2<=cost and attack2>=attack.
