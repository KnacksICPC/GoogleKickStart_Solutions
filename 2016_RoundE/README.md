diwaliLightings.py: We can simulate the process with modulo operations.

beautifulNumbers.py: We want to find if (X^(N+1)-1)/(X-1)==A has an integer answer. Since the derivative is always positive, we can fix N and binary search on X. Note that fixing X will not work, because there are so many possibilities for X, whereas N can only take values in the range \[2,64].

partitioningNumber.cpp: We iterate over all possible length of the sequence L. For a fixed L, there are at most 3 possibilities for the starting value A at the left most bucket. For each of these 3 possibilities, if we fix the length of A to be n1, then there is a unique solution for the length of A+1 (let us call it n2) and the length of A+2 (let us call it n3). We can calculate the lower bound of n1 by taking as much n3 and as fewer n2 as possible, and we can calculate the upper bound of n1 by taking as much n2 and as fewer n3 as possible. Thus for each fixed L and fixed A, the result is increased by (upper bound of n1- lower bound of n1), since each n1 determines a unique combination of n2 and n3. Note that to avoid repetition, we can set minimum bound for n1,n2 or n3. For example, if we want all three values (A, A+1, A+2) to be present, we would set their minimum bound to be 1. 

sortingArray.cpp: Since no one on the internet has written detailed analysis of this problem so far, I would like to explain in detail the logic behind this problem. (Note that helper.py will generate a good number of input for this problem, which can be used for debugging purpose.) We first preprocess the numbers array to record the maximum number of segments each interval can be splitted into (without swapping). There are a total of N^2 intervals, let us denote A as an interval starting from index L and ending at index R, i.e. \[L...R]. Let us denote the maximum segments that A can be splitted into as S. To iterate every interval, we start from each starting index L, and as we are iterating through the ending index R, we record the maximum element we have seen so far as maxA, and the minimum element we have seen so far as minA. Now, if the new number E we are looking at (the number at index R) is smaller than minA, this means that the interval \[L..E] can never be splitted, because E is the smallest element, any split will cause the interval to be out of order. Thus if E<minA, we reset S to 1. On the other hand, if E>minA and maxA-minA==R-L, this means that the current interval, if sorted, contains consecutive numbers (i.e. every neighboring numbers differ by 1). Thus we can record the S of current interval as previous S plus 1, and then we can increase S by 1. We are safe to use the value of S+1 because greedily, we always split whenever we can, so that we have the maximum value for S whenever possible. If maxA-minA != R-L, this means the current interval cannot be sorted to fit in (even swapping won't help), and thus we store S=0 for the current interval. We store the S value for each interval, and also record the number of shift required by each interval (the shift amount can be calculated as minA-1-L). This concludes all the preprocessing. Now, Let us call the segments being swapped as B,C,D. (let's also assume B,C,D is the order they appear in the original sequence). A key observation is that no matter 2 or 3 segments being swapped, all the swapped segments must together form a valid interval with shift amount==0. Moreover, anything before B must be an interval with shift amount==0 and anything after D must also be an interval with shift amount==0. Thus, we can iterate, and observe in between any two segments that have shift amount==0, and B,C,D must exist in between. With this observation, we can consider the swapping effects. case I: If there are only two segments to be swapped, let us denote them as B,C. Then B must move to where C is, and C must move to where B is. case II: If there are three segments to be swapped, let us denote the segment between B and C as D, and the segment between C and D as E. If B is swapped to D, and D is swapped to B, this degenerates to the previous case. If B is swapped to D, and D is swapped to C, C must be swapped to B. Similarly, If D is swapped to B, and B is swapped to C, C must swap to D. Note that swapping C to D and D to C is invalid, because the "shift amount==0 segments" mentioned earlier will shrink. In summary, for swapping 3 segments, out of the 6 topologies (3 factorial), only 2 needs to be calculated, 2 will degenerate, and 2 are invalid. Finally, we can iterate the length of B,C,D and calculate the maximum segments after swapping. Since each of B,C,D is O(N) complexity, the overall time complexity is O(N^3) for large dataset. 
